---
layout:     post

title:      "RSA算法"

subtitle:   ""

date:       2017-08-07 10:40:00

author:     "renchao"

header-img: "img/2017.05.07.jpg"

tags: 

- 算法
---

### RSA算法

![img](http://image.beekka.com/blog/201307/bg2013070301.png)

在算法世界里，非常重要的一个算法就是RSA算法。因为RSA算法是网络世界中保证安全的基石之一。只要在有网络的地方，就有RSA的存在，可见RSA算法的地位。

写本文的目的是真正理解RSA算法为什么能够非常安全，参考了阮一峰老师的一片博客：[RSA算法原理](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)。

#### 概述

对称加密是通过同一份密钥加密和解密数据，而非对称加密则有两份密钥，分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密，用私钥加密的数据，要用公钥才能解密。此时私钥加密是作为一种认证信息。

简单说一下常用的非对称加密算法 RSA 的数学原理，理解简单的数学原理，就可以理解非对称加密是怎么做到的，为什么会是安全的：

1. 选两个质数 p 和 q，相乘得出一个大整数n，例如 p = 61，q = 53，n = pq = 3233
2. 选 1-n 间的随便一个质数e，例如 e = 17
3. 经过一系列数学公式，算出一个数字 d，满足：
   a.通过 n 和 e 这两个数据一组数据进行数学运算后，可以通过 n 和 d 去反解运算，反过来也可以。
   b.如果只知道 （n 和 e）（公钥），要推导出 d，需要知道 p 和 q，也就是要需要把 n 因数分解。

上述的 (n,e) 这两个数据在一起就是**公钥**，(n,d) 这两个数据就是**私钥**，满足用私钥加密，公钥解密，或反过来公钥加密，私钥解密，也满足在只暴露公钥 (只知道 n 和 e)的情况下，要推导出私钥 (n,d)，需要把大整数 n 因数分解。目前因数分解只能靠暴力穷举，而 n 数字越大，越难以用穷举计算出因数 p 和 q，也就越安全，当 n 大到二进制 1024 位或 2048 位时，以目前技术要破解几乎不可能，所以非常安全。

#### 用例子来讲述密钥生成的步骤

假设场景为：李明给女神亦菲发送短信，但是不想让其他人知道，于是就使用RSA算法来加密告白短信。那么公钥和私钥的生成步骤为：

**第一步，随机选择两个不相等的质数p和q**

李明选择了61和53。（实际应用中，质数要更大，以防破解）

**第二步，将p和q相乘得到n** 

```
n = 61 x 53 = 3233
```

n的长度就是密钥长度。3233二进制为110010100001，一共12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，或2048位。

**第三步，计算n的欧拉公式φ(n)**

```
φ(n) = （p - 1）（q - 1）
```

所以，李明算出来φ(3233)等于60×52，即3120。

**第四步，随机选择一个整数e，使得1< e < φ(n)并且e与φ(n)互质**

李明就随机选择了17。（实际应用中常常选择65537）

**第五步，计算e对于φ(n)的模反元素d**

”模反元素“就是指有一个整数d，可以使得ed被φ(n)除的余数为1。

```
ed ≡ 1 (mod φ(n))
```

这个式子等价于

```
ed - 1 = kφ(n)
```

于是，找到模反元素d，其实就是对下面这个二元一次方程进行求解：

```
ex + φ(n)y = 1
```

现在已知的数为，e=17，φ(n)=3120，所以：

```
17x + 3120y = 1
```

这个方程的求解可以用扩展欧几里得算法，省略具体过程。

总之，李明算出了一组整数解为（x，y）=（2753，-15），即 d = 2753。

至此，所有计算完成。

**第六步，将n和e封装为公钥，n和d封装为私钥**

在这个例子里，n = 3233，e = 17，d = 2753，所以公钥就是（n，e）=（3233，17），私钥就是（n，d）=（3233，2753）。

实际应用中，公钥私钥的数据都是采用ASN.1的格式表达。

#### 为什么RSA可靠？

回顾上面密钥的生成步骤，一共有六个元素：p q n φ(n) e d

这六个元素中，公钥用到了n和e，其余四个都不公开。其中最关键的是d，因为n和d组成了私钥，一旦d泄露，就相当于私钥泄露。

**在已知n和e的情况下，能否推导出私钥的关键元素d？**

```
因为 ed≡1 (mod φ(n)) ，所以只有知道了e和φ(n)，才能算出d。
因为 φ(n)=(p-1)(q-1) ，所以只有知道了p和q，才能算出φ(n)。
因为 n = pq ，所以只有将 n 进行因数分解，才能算出p和q。
```

所以：如果n可以被因数分解，d就能够直到，也就意味着私钥被破解。

可是对于大整数的因数分解，是一件非常困难的事。暴力破解？好像只能这样。

> 维基百科：
>
>  　  "对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。
>
> 　　假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。
>
> ​      只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。"

举个例子：

```
　　12301866845301177551304949
　　58384962720772853569595334
　　79219732245215172640050726
　　36575187452021997864693899
　　56474942774063845925192557
　　32630345373154826850791702
　　61221429134616704292143116
　　02221240479274737794080665
　　351419597459856902143413
```

你能对这个数进行因数分解吗？它等于这样两个数相乘：

```
　　33478071698956898786044169
　　84821269081770479498371376
　　85689124313889828837938780
　　02287614711652531743087737
　　814467999489
　　　　×
　　36746043666799590428244633
　　79962795263227915816434308
　　76426760322838157396665112
　　79233373417143396810270092
　　798736308917
```

事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。

#### 加密和解密

##### 加密

李明可以用公钥（n，e）向亦菲发送短信了，假设短信文本为m（这里m必须是整数，字符串可以转换成ascii或unicode值），且m必须小于n。

加密的实质就是算出下面式子中的c：

```
m^e ≡ c (mod n)
```

公钥（3233，17），假设 m = 65，所以也就是

```
65^17 ≡ 2790 (mod 3233)
```

于是c等于2790，李明就把2790发给了亦菲。

##### 解密

亦非收到了李明的神秘字符2790后，就拿着自己的私钥（3233，2753）进行解密，

可以证明下面公式一定成立：（后面有证明）

```
c^d ≡ m (mod n)
```

也就是：

```
2790^2753 = 65(mod 3233)
```

所以亦非知道了李明发来的消息原来是65啊。

---

至此，“加密-解密”整个过程全部完成。

我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。

你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种"对称性加密算法"（比如[DES](https://zh.wikipedia.org/wiki/%E8%B5%84%E6%96%99%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86)），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。

#### 证明私钥解密的公式

最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：

```
c^d ≡ m (mod n)
```

因为，根据加密规则

```
m^e ≡ c (mod n)
```

于是，c可以写成下面的形式：

```
c = m^e - kn
```

将c代入要我们要证明的那个解密规则：

```
(m^e - kn)^d ≡ m (mod n)
```

它等同于求证

```
m^ed ≡ m (mod n)
```

由于

```
ed ≡ 1 (mod φ(n))
```

所以

```
ed = hφ(n)+1
```

将ed代入：

```
　　m^hφ(n)+1 ≡ m (mod n)
```

接下来，分成两种情况证明上面这个式子。

**（1）m与n互质。**

根据欧拉定理，此时

```
m^φ(n) ≡ 1 (mod n)
```

得到

```
(m^φ(n))^h × m ≡ m (mod n)
```

原式得到证明。

**（2）m与n不是互质关系。**

此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。

以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：

```
(kp)^(q-1) ≡ 1 (mod q)
```

进一步得到

```
[(kp)^(q-1)]^(h(p-1)) × kp ≡ kp (mod q)
```

即

```
(kp)^ed ≡ kp (mod q)
```

将它改写成下面的等式

```
(kp)^ed = tq + kp
```

这时t必然能被p整除，即 t=t'p

```
(kp)^ed = t'pq + kp
```

因为 m=kp，n=pq，所以

```
m^ed ≡ m (mod n)
```

原式得到证明。