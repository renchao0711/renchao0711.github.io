---
layout:     post

title:      "一个iOSer对Java GC垃圾回收的理解"

subtitle:   ""

date:       2017-07-13 15:25:00

author:     "renchao"

header-img: "img/2017.05.07.jpg"

tags: 

- Java
---



## 一个iOSer对Java GC垃圾回收的理解

### 前言

对于用OC写的iOS程序来说，内存管理机制是非常重要的内容。OC中采用引用计数的机制，对象的引用计数器会因被引用而加1，被释放而减1。当引用计数为0时，便将该内存收回。这就要求程序员在合适的地方加上计数语句，非常麻烦。还好后来出现了ARC自动引用计数，编译器自动加语句而让程序员的工作大大减少，但是对于C对象还是要手动管理。这种机制的优点是简单，后期的使用也会因内存的合理分配而流畅。缺点是会造成循环引用，内存泄露。所以要注意内存泄漏问题。

那么基于Java的安卓内存管理是怎样的呢？

### 判断对象是否死亡

#### 1.引用计数算法

同iOS内存管理机制，不再重复。

#### 2.可达性分析算法

是通过一些列的称为GCRoots的对象作为起始点，从这些节点开始向搜索，搜索所走的路径称为引用链，当一个对象叨叨GCRoots没有任何引用链相连时，就证明对象是不可用的。可以作为GCRoots的对象有四种：

- 虚拟机栈中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象。

即使在可达性分析算法中不可达的对象，也并非是真正的非死不可的，它是处于一个缓刑阶段，要真正判断一个对象死亡，至少要经历两次标记的过程：

如果对象在进行可达性分析后没有发现与GCRoots相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象有没有必要执行finalize方法，当对象没有覆盖finalize方法或者finalize方法被虚拟机调用过，就认为没有必要执行。如果对象没有必要执行finalize方法，那这个对象就会被放置在F-Queue的队列中，并且稍后由一个虚拟机自动建立，低优先级的Finalizer线程去执行。finalize方法是对象逃脱死亡的最后一次机会，稍后GC会对F-Queue中的对象进行二次小规模的标记，只要对象在finalize中重新与引用链上的任何对象建立连接就行，在第二次标记的时候就会被移除队列，如果对象还没有逃脱那么就会真的被回收了。

> finalize方法：
>
> 

### 回收算法

#### 1.标记-清除算法

标记清除算法分为标记和清除两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它主要有两个缺点：

- 效率问题，标记和清除连个过程的效率都不高。
- 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到连续内存而不得不提前触发另一次GC。

#### 2.复制算法

为了解决效率问题，我们引入了一种复制算法，它将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了就将还存活的对象复制到另一块中，然后再把已经使用过的内存一次清理掉。这样使得每次只对整个半区内存回收，也就不用考虑标记清除带来的碎片问题。它的优点是实现简单，运行高效。但是缺点内存代价太高，每次要花费一般的内存空间，当收集存活率比较高的对象时，就要进行较多次的复制，效率就会变得低下。

#### 3.标记-整理算法

先对对象进行标记，然后将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

#### 4.分代收集算法

分代收集算法就是根据各个年代的特点采用最适当的算法来收集，在新生代中，每次回收都有大量的对象死去，只有少量的对象存活，所以选择用复制算法，只需要付出少量存活对象的空间就可以完成收集，而在老年代中对象的存活率非常的高，没有额外空间对它进行分配，所以使用标记清除或者标记整理算法来完成回收。

### 对象分代

对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲将按线程优先在tlab上分配，少数情况下也有可能直接分配在老年代中，分配的规则并不是百分百固定。

#### 1.对象优先在Eden区分配

大多数情况下对象在新生代Eden中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次GC。

#### 2.大对象直接进入老年代

所谓大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组，让大对象直接在老年代分配，这样的目的是避免Eden和两个Survivor区之间发生大量的内存复制。

#### 3.长期存活的对象将进入老年代

虚拟机给每一个对象定义了一个年龄计数器，如果对象在Eden出生并经过了第一次GC仍然存活，就被Survivor容纳。进入Survivor空间中，并且对象年龄设为1，对象在Survivor中熬过一次GC年龄就增加为1岁，当它的年龄增加到一定程度时（默认为15岁）就会晋级为老年代。

#### 4.动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到那个标志才晋级老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到默认的年龄15再进入。