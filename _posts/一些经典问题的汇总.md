### 操作系统

CPU在执行进程指令时要取一个实际的物理地址的值主要有几步：

1. 把进程指令使用的虚拟地址通过MMU（存储器管理单元）转换成物理地址
2. 把物理地址映射到高速缓存的缓存行
3. 如果高速缓存命中就返回
4. 如果不命中，就产生一个缓存缺失中断，从主存相应的物理地址取值，并加载到高速缓存中。CPU从中断中恢复，继续执行中断前的指令



死锁：一个进程在执行过程中需要其他资源而陷入等待，但是其他资源的获取需要其他进程的执行，但是进程不能执行而导致都陷入了等待状态。

四个条件：互斥、请求和保持、不可抢占、循环等待。

处理方法：

1. 预防死锁

   1. 破坏请求保持条件：在开始运行之前就申请到所有所需的资源，优点是简单易行安全，但是缺点是资源严重被浪费，进程容易出现饥饿现象。改进一下就是，允许一个进程只获得初期所需的资源就开始运行，逐步再释放资源请求资源。
   2. 破坏不可抢占条件：当一个已经保持了某些不可被强占资源的进程，提出新的资源请求而不得到满足时，必须释放保持的资源，需要时再重新申请。实现起来比较复杂而且需要付出很大代价。可能因为反复申请和释放资源而导致进程的执行被无限推迟。不仅延长了进程的周转时间，也增加了系统开销，降低系统的吞吐量。
   3. 破坏循环等待条件：将资源线性排序，按序号请求资源。如果某进程已经请求到高序号的资源，后来又想请求序号低的资源，那么就需要先释放所有具有相同序号或更高的资源才能申请低序号的资源。这样就不会出现环路。事实上总有一个进程占据较高序号的资源，此后它继续申请的资源必定是空闲的，所以进程可以一直推进。问题是：序号相对稳定，限制了新类型设备的增加；使用资源的顺序和系统规定的顺序不同，导致资源的浪费；限制用户自主编程。

2. 避免死锁

   也是属于事先预防的策略，是在资源动态分配的过程中，防止系统进入不安全状态。

   使用银行家算法避免死锁。

3. 检测死锁

   保持相关资源的请求和分配信息，提供某种算法检测是否死锁状态。

4. 解除死锁：

   1. 从其他进程中抢占足够多的资源，分配给死锁进程。
   2. 终止或撤销死锁进程，直到打破环路。

   ​

页面置换算法

1. 最佳置换算法：被淘汰页将是以后永不使用或最长时间内不再被访问的页面。

2. 先进先出算法：总是淘汰最先进入的页面。

3. 最近最久未使用算法（LRU）：选择最近最久未使用的页面淘汰。（时间）

4. 最少使用算法（LFU）：选择最近时期使用最少的页面淘汰。（频率）

5. Clock算法：为每页设置一位访问位，再将内存中所有页面都通过链接指针连接成一个循环队列，某页被访问时，置1，淘汰时，检查访问位，0则换出，1则置0。

6. Clock改进：修改过的页面换出时代价较大，所以改进版不仅考虑使用情况，还要考虑是否被修改。

   未被访问+未被修改 = 最佳淘汰页

   未被访问+被修改 = 不是很好的淘汰页

   最近被访问+未被修改 = 可能再次被访问

   最基本访问+被修改 = 可能再被访问，几率更大

7. 页面缓冲算法（PBA）：特点是降低页面换进换出的频率，内存分配策略上采用了可变分配和局部置换的方式，系统为每个进程分配一定数目的物理块，系统自己保留一部分空闲物理块。为了降低换进换出的频率，在内存中设置两个链表：

   1. 空闲页面链表：是一个空闲物理块链表，是系统掌握的空闲物理块，用于分配给频繁发生缺页的进程，降低该进程的缺页率。当这样的进程需要读入一个页面时，可利用空闲物理块链表的第一个物理块来装入该页。当有一个为被修改过的页要换出时，实际上并不是换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。注意：这些挂在空闲链表上的未被修改的页面中是有数据的，如果以后某进程需要这些页面数据，便可以从空闲链表中取下，免除从磁盘读取的操作，减少页面换出的开销。
   2. 修改页面链表：由已修改页面形成的链表，设置该链表的目的是减少已修改页面换出的次数。当今程序需要将一个页面换出时，并不直接换出到磁盘，而是将它所在物理块挂在修改页面链表的末尾，降低了已修改页面换出的频率。