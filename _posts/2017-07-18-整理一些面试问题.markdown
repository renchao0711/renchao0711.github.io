---
layout:     post
title:      "整理一些面试问题"
subtitle:   ""
date:       2017-07-18 19:00:00
author:     "renchao"
header-img: "img/2017.05.03.jpg"
tags: 
   - 面试
---

# 整理一些面试问题

[TOC]

## 数据结构与算法

##### 栈和队列的应用

函数调用 递归调用 断点实现 符号匹配 计算代数式 CPU的资源分配等

##### 海量数据查找top

对于100w个数据求几个数，其实总量也就是4*1000000 = 4M，直接堆排序就可以。如下面的例题：

```
    搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录， 这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。 
（1）请描述你解决这个问题的思路； 
（2）请给出主要的处理流程，算法，以及算法的复杂度。
    我们知道，数据大则划为小的，但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去，而现在只是需要一个合适的数据结构，在这里，Hash Table绝对是我们优先的选择。所以我们摒弃分而治之/hash映射的方法，直接上hash统计，然后排序。So:
    1.hash统计：先对这批海量数据预处理(维护一个Key为Query字串，Value为该Query出现次数的HashTable，即Hashmap(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；
    2.堆排序：第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N'*O（logK），（N为1000万，N’为300万）。
```

更高数量级：

```
一个文本文件，也是找出前十个最经常出现的词，但这次文件比较长，说是上亿行或者十亿行，总之无法一次读入内存，问最优解。
     1）hash映射：hash(单词) % 1000, 这样这些单词就分布在1000个小文件中
     2）hash统计：用hashmap或者trie树进行统计，找出每个小文件中的最常出现的10个词
     3）堆排序：用第一个文件的10个最常出现词构建小根堆，然后依次读入剩下999个文件的最常出现单词，调整对，最后将得到总体的最常出现词
```

##### 动态规划和贪心算法的区别

这两种算法都是递推算法，都是通过局部最优解来推导出全局最优解。

贪心算法的思路是，从问题的某个初始解出发逐步逼近给定的目标，以尽可能快的求得更好的解。当到达某个算法的某一步不能再继续前进时，算法停止。该算法存在的问题在于，不能保证最后的解是最佳的，不能用来求得最大最小问题解问题，只能求满足某些约束条件的可行解的范围。最经典的例子就是给钱问题。每次都拿最大的，这就是贪心，但是贪心得到的不一定是最优解，不一定是张数最少的，只是一个比较好的，效率比较高的解。

不同之处在于，贪心算法做的每一步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一步之前的最优解则不做保留。所以每一步的最优解一定包含上一步的最优解。贪心特殊在每个子树的根值不取决于下面叶子值，而只取决于当前问题的状态。也就是说，不需要知道每个节点的子树情况就可以求出这个节点的值，这个值通常都是当前情况下显而易见最优的。自根开始，选择最优的路一路走到底就可以。

但是动态规划中，全局最优解一定包含了局部最优解，但是不一定是上一步的局部最优解，所以需要记录之前所有最优解。关键在于如何由已求得的局部最优解来推导出全局最优解。与动态规划相比，贪心的代价只取决于子问题的数目，而选择数目总为1。动态规划的经典例子是最长公共子序列问题。

##### 实现进程的互斥

1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
2、互斥量:为协调共同对一个共享资源的单独访问而设计的。 
3、信号量:为控制一个具有有限数量用户资源而设计。                                                                                                4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

四大原则：忙则等待 空闲让进 有限等待 让权等待

## 计算机网络

## iOS相关

##### category的意义和实现

**意义**就是可以在本类中直接添加方法而不用新建一个子类。团队协作的时候可以明确分工，不同的任务有不同的划分，便于合作、阅读和维护。AFN，SDW等就用到了分类。声明私有方法等。

但是缺点是无法添加成员变量，但可以通过runtime的关联方法实现。分类的方法具有更高响应优先级，所以可能导致原始类以及父类的方法得不到调用，可以通过runtime遍历同名方法，取最后的方法。

**实现**：其实实现主要在runtime源码的`objc-runtime-new.mm`文件下，有一个叫做read_images的方法，将category和主类或元类注册到哈希表中，如果主类或元类已经实现了，就重建方法列表。分两种情况：Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中。另外，对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中。在`remethodizeClass`方法里，将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 `data()` 中 `method_lists（或 method_list）`、`properties` 和 `protocols` 的值。进一步，我们通过 `attachCategoryMethods` 函数的源码可以找到真正处理 Category 方法的 `attachMethodLists` 函数：`attachMethodLists`。

它的主要作用就是将类中的旧有方法和 Category 中新添加的方法整合成一个新的方法列表，并赋值给 `method_lists` 或 `method_list` 。通过探究这个处理过程，我们也印证了一个结论，那就是主类中的方法和 Category 中的方法在 runtime 看来并没有区别，它们是被同等对待的，都保存在主类的方法列表中。

不过，类的方法列表字段有一点特殊，它的结构是联合体，`method_lists` 和 `method_list` 共用同一块内存地址。当 `newCount` 的个数大于 1 时，使用 `method_lists` 来保存 `newLists` ，并将方法列表的**标志位**置为 `RW_METHOD_ARRAY` ，此时类的方法列表字段是 `method_list_t` 类型的指针数组；否则，使用 `method_list` 来保存 `newLists` ，并将方法列表的**标志位**置空，此时类的方法列表字段是 `method_list_t` 类型的指针。

## 数据库