---
layout:     post
title:      "整理一些经典问题"
subtitle:   "包括数据结构和算法、网络、iOS等"
date:       2017-07-18 19:00:00
author:     "renchao"
header-img: "img/2017.05.03.jpg"
tags: 
   - 面试
---

# 整理一些经典问题

[TOC]

## 数据结构与算法

##### 栈和队列的应用

函数调用 递归调用 断点实现 符号匹配 计算代数式 CPU的资源分配等

##### 海量数据查找top

对于100w个数据求几个数，其实总量也就是4*1000000 = 4M，直接堆排序就可以。如下面的例题：

```
    搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录， 这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。 
（1）请描述你解决这个问题的思路； 
（2）请给出主要的处理流程，算法，以及算法的复杂度。
    我们知道，数据大则划为小的，但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去，而现在只是需要一个合适的数据结构，在这里，Hash Table绝对是我们优先的选择。所以我们摒弃分而治之/hash映射的方法，直接上hash统计，然后排序。So:
    1.hash统计：先对这批海量数据预处理(维护一个Key为Query字串，Value为该Query出现次数的HashTable，即Hashmap(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；
    2.堆排序：第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N'*O（logK），（N为1000万，N’为300万）。
```

更高数量级：

```
一个文本文件，也是找出前十个最经常出现的词，但这次文件比较长，说是上亿行或者十亿行，总之无法一次读入内存，问最优解。
     1）hash映射：hash(单词) % 1000, 这样这些单词就分布在1000个小文件中
     2）hash统计：用hashmap或者trie树进行统计，找出每个小文件中的最常出现的10个词
     3）堆排序：用第一个文件的10个最常出现词构建小根堆，然后依次读入剩下999个文件的最常出现单词，调整对，最后将得到总体的最常出现词
```

##### 动态规划和贪心算法的区别

这两种算法都是递推算法，都是通过局部最优解来推导出全局最优解。

贪心算法的思路是，从问题的某个初始解出发逐步逼近给定的目标，以尽可能快的求得更好的解。当到达某个算法的某一步不能再继续前进时，算法停止。该算法存在的问题在于，不能保证最后的解是最佳的，不能用来求得最大最小问题解问题，只能求满足某些约束条件的可行解的范围。最经典的例子就是给钱问题。每次都拿最大的，这就是贪心，但是贪心得到的不一定是最优解，不一定是张数最少的，只是一个比较好的，效率比较高的解。

不同之处在于，贪心算法做的每一步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一步之前的最优解则不做保留。所以每一步的最优解一定包含上一步的最优解。贪心特殊在每个子树的根值不取决于下面叶子值，而只取决于当前问题的状态。也就是说，不需要知道每个节点的子树情况就可以求出这个节点的值，这个值通常都是当前情况下显而易见最优的。自根开始，选择最优的路一路走到底就可以。

但是动态规划中，全局最优解一定包含了局部最优解，但是不一定是上一步的局部最优解，所以需要记录之前所有最优解。关键在于如何由已求得的局部最优解来推导出全局最优解。与动态规划相比，贪心的代价只取决于子问题的数目，而选择数目总为1。动态规划的经典例子是最长公共子序列问题。

##### 实现进程的互斥

1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
2、互斥量:为协调共同对一个共享资源的单独访问而设计的。 
3、信号量:为控制一个具有有限数量用户资源而设计。                                                                                                4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

四大原则：忙则等待 空闲让进 有限等待 让权等待

## 计算机网络

## iOS相关

##### category的意义和实现

**意义**就是可以在本类中直接添加方法而不用新建一个子类。团队协作的时候可以明确分工，不同的任务有不同的划分，便于合作、阅读和维护。AFN，SDW等就用到了分类。声明私有方法等。

但是缺点是无法添加成员变量，但可以通过runtime的关联方法实现。分类的方法具有更高响应优先级，所以可能导致原始类以及父类的方法得不到调用，可以通过runtime遍历同名方法，取最后的方法。

**实现**：其实实现主要在runtime源码的`objc-runtime-new.mm`文件下，有一个叫做read_images的方法，将category和主类或元类注册到哈希表中，如果主类或元类已经实现了，就重建方法列表。分两种情况：Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中。另外，对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中。在`remethodizeClass`方法里，将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 `data()` 中 `method_lists（或 method_list）`、`properties` 和 `protocols` 的值。进一步，我们通过 `attachCategoryMethods` 函数的源码可以找到真正处理 Category 方法的 `attachMethodLists` 函数：`attachMethodLists`。

它的主要作用就是将类中的旧有方法和 Category 中新添加的方法整合成一个新的方法列表，并赋值给 `method_lists` 或 `method_list` 。通过探究这个处理过程，我们也印证了一个结论，那就是主类中的方法和 Category 中的方法在 runtime 看来并没有区别，它们是被同等对待的，都保存在主类的方法列表中。

不过，类的方法列表字段有一点特殊，它的结构是联合体，`method_lists` 和 `method_list` 共用同一块内存地址。当 `newCount` 的个数大于 1 时，使用 `method_lists` 来保存 `newLists` ，并将方法列表的**标志位**置为 `RW_METHOD_ARRAY` ，此时类的方法列表字段是 `method_list_t` 类型的指针数组；否则，使用 `method_list` 来保存 `newLists` ，并将方法列表的**标志位**置空，此时类的方法列表字段是 `method_list_t` 类型的指针。

##### Tagged Pointer

2013年9月推出了首次搭载64架构A7双核处理器的5s。为了节省内存和提高效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。

我们先看看原有的对象为什么会浪费内存。假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。所以一个普通的iOS程序，如果没有`Tagged Pointer`对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。

我们再来看看效率上的问题，为了存储和访问一个NSNumber对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失。

为了改进上面提到的内存占用和效率问题，苹果提出了`Tagged Pointer`对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。所以，引入了`Tagged Pointer`对象之后，64位CPU下NSNumber的内存图变成了以下这样：

![img](http://cdn1.infoqstatic.com/statics_s2_20170801-0326/resource/articles/deep-understanding-of-tagged-pointer/zh/resources/0519061.jpg)

WWDC2013的《Session 404 Advanced in Objective-C》视频中，看到苹果对于`Tagged Pointer`特点的介绍：

1. `Tagged Pointer`专门用来存储小的对象，例如`NSNumber`和`NSDate`
2. `Tagged Pointer`指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。
3. 在内存读取上有着3倍的效率，创建时比以前快106倍。

苹果将`Tagged Pointer`引入，给64位系统带来了内存的节省和运行效率的提高。`Tagged Pointer`通过在其最后一个bit位设置一个特殊标记，用于将数据直接保存在指针本身中。因为`Tagged Pointer`并不是真正的对象，我们在使用时需要注意不要直接访问其isa变量。

## 操作系统

##### CPU取值步骤

CPU在执行进程指令时要取一个实际的物理地址的值主要有几步：

1. 把进程指令使用的虚拟地址通过MMU（存储器管理单元）转换成物理地址
2. 把物理地址映射到高速缓存的缓存行
3. 如果高速缓存命中就返回
4. 如果不命中，就产生一个缓存缺失中断，从主存相应的物理地址取值，并加载到高速缓存中。CPU从中断中恢复，继续执行中断前的指令

##### 死锁

死锁：一个进程在执行过程中需要其他资源而陷入等待，但是其他资源的获取需要其他进程的执行，但是进程不能执行而导致都陷入了等待状态。

四个条件：互斥、请求和保持、不可抢占、循环等待。

处理方法：

1. 预防死锁

   1. 破坏请求保持条件：在开始运行之前就申请到所有所需的资源，优点是简单易行安全，但是缺点是资源严重被浪费，进程容易出现饥饿现象。改进一下就是，允许一个进程只获得初期所需的资源就开始运行，逐步再释放资源请求资源。
   2. 破坏不可抢占条件：当一个已经保持了某些不可被强占资源的进程，提出新的资源请求而不得到满足时，必须释放保持的资源，需要时再重新申请。实现起来比较复杂而且需要付出很大代价。可能因为反复申请和释放资源而导致进程的执行被无限推迟。不仅延长了进程的周转时间，也增加了系统开销，降低系统的吞吐量。
   3. 破坏循环等待条件：将资源线性排序，按序号请求资源。如果某进程已经请求到高序号的资源，后来又想请求序号低的资源，那么就需要先释放所有具有相同序号或更高的资源才能申请低序号的资源。这样就不会出现环路。事实上总有一个进程占据较高序号的资源，此后它继续申请的资源必定是空闲的，所以进程可以一直推进。问题是：序号相对稳定，限制了新类型设备的增加；使用资源的顺序和系统规定的顺序不同，导致资源的浪费；限制用户自主编程。

2. 避免死锁

   也是属于事先预防的策略，是在资源动态分配的过程中，防止系统进入不安全状态。

   使用银行家算法避免死锁。

3. 检测死锁

   保持相关资源的请求和分配信息，提供某种算法检测是否死锁状态。

4. 解除死锁：

   1. 从其他进程中抢占足够多的资源，分配给死锁进程。
   2. 终止或撤销死锁进程，直到打破环路。

   ​

##### 页面置换算法

1. 最佳置换算法：被淘汰页将是以后永不使用或最长时间内不再被访问的页面。

2. 先进先出算法：总是淘汰最先进入的页面。

3. 最近最久未使用算法（LRU）：选择最近最久未使用的页面淘汰。（时间）

4. 最少使用算法（LFU）：选择最近时期使用最少的页面淘汰。（频率）

5. Clock算法：为每页设置一位访问位，再将内存中所有页面都通过链接指针连接成一个循环队列，某页被访问时，置1，淘汰时，检查访问位，0则换出，1则置0。

6. Clock改进：修改过的页面换出时代价较大，所以改进版不仅考虑使用情况，还要考虑是否被修改。

   未被访问+未被修改 = 最佳淘汰页

   未被访问+被修改 = 不是很好的淘汰页

   最近被访问+未被修改 = 可能再次被访问

   最基本访问+被修改 = 可能再被访问，几率更大

7. 页面缓冲算法（PBA）：特点是降低页面换进换出的频率，内存分配策略上采用了可变分配和局部置换的方式，系统为每个进程分配一定数目的物理块，系统自己保留一部分空闲物理块。为了降低换进换出的频率，在内存中设置两个链表：

   1. 空闲页面链表：是一个空闲物理块链表，是系统掌握的空闲物理块，用于分配给频繁发生缺页的进程，降低该进程的缺页率。当这样的进程需要读入一个页面时，可利用空闲物理块链表的第一个物理块来装入该页。当有一个为被修改过的页要换出时，实际上并不是换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。注意：这些挂在空闲链表上的未被修改的页面中是有数据的，如果以后某进程需要这些页面数据，便可以从空闲链表中取下，免除从磁盘读取的操作，减少页面换出的开销。
   2. 修改页面链表：由已修改页面形成的链表，设置该链表的目的是减少已修改页面换出的次数。当今程序需要将一个页面换出时，并不直接换出到磁盘，而是将它所在物理块挂在修改页面链表的末尾，降低了已修改页面换出的频率。

## 数据库

##### 范式

第一范式：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。第一范式就是每一个属性都不可再分，不符合第一范式则不能称为关系数据库。

第二范式：若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。简单的说，是表中的属性必须完全依赖于全部主键，而不是部分主键.所以只有一个主键的表如果符合第一范式，那一定是第二范式。这样做的目的是进一步减少插入异常和更新异常。

第三范式：是为了消除数据库中关键字之间的依赖关系。

bc范式：是在第三范式的基础上的一种特殊情况，既每个表中只有一个候选键（在一个数据库中每行的值都不相同，则可称为候选键）。

第四范式：是消除表中的多值依赖，也就是说可以减少维护数据一致性的工作。

总结：

​     上面对于数据库范式进行分解的过程中不难看出，应用的范式登记越高，则表越多。表多会带来很多问题：

1. 查询时要连接多个表，增加了查询的复杂度

2. 查询时需要连接多个表，降低了数据库查询性能

   而现在的情况，磁盘空间成本基本可以忽略不计，所以数据冗余所造成的问题也并不是应用数据库范式的理由。

因此，并不是应用的范式越高越好，要看实际情况而定。第三范式已经很大程度上减少了数据冗余，并且减少了造成插入异常，更新异常，和删除异常了。我个人观点认为，大多数情况应用到第三范式已经足够，在一定情况下第二范式也是可以的。

分享：[数据库那些事](http://www.cnblogs.com/CareySon/archive/2010/02/16/1668803.html)