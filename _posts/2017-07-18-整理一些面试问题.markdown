---
layout:     post
title:      "整理一些面试问题"
subtitle:   ""
date:       2017-07-18 19:00:00
author:     "renchao"
header-img: "img/2017.05.03.jpg"
tags: 
   - 面试
---

# 整理一些面试问题

[TOC]

## 数据结构与算法

##### 栈和队列的应用

函数调用 递归调用 断点实现 符号匹配 计算代数式 CPU的资源分配等

##### 海量数据查找top

对于100w个数据求几个数，其实总量也就是4*1000000 = 4M，直接堆排序就可以。如下面的例题：

```
    搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录， 这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。 
（1）请描述你解决这个问题的思路； 
（2）请给出主要的处理流程，算法，以及算法的复杂度。
    我们知道，数据大则划为小的，但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去，而现在只是需要一个合适的数据结构，在这里，Hash Table绝对是我们优先的选择。所以我们摒弃分而治之/hash映射的方法，直接上hash统计，然后排序。So:
    1.hash统计：先对这批海量数据预处理(维护一个Key为Query字串，Value为该Query出现次数的HashTable，即Hashmap(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；
    2.堆排序：第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N'*O（logK），（N为1000万，N’为300万）。
```

更高数量级：

```
一个文本文件，也是找出前十个最经常出现的词，但这次文件比较长，说是上亿行或者十亿行，总之无法一次读入内存，问最优解。
     1）hash映射：hash(单词) % 1000, 这样这些单词就分布在1000个小文件中
     2）hash统计：用hashmap或者trie树进行统计，找出每个小文件中的最常出现的10个词
     3）堆排序：用第一个文件的10个最常出现词构建小根堆，然后依次读入剩下999个文件的最常出现单词，调整对，最后将得到总体的最常出现词
```

## 操作系统 

##### 实现进程的互斥

1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
2、互斥量:为协调共同对一个共享资源的单独访问而设计的。 
3、信号量:为控制一个具有有限数量用户资源而设计。                                                                                                4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

四大原则：忙则等待 空闲让进 有限等待 让权等待

## 计算机网络

## iOS相关

##### category的意义和实现

**意义**就是可以在本类中直接添加方法而不用新建一个子类。团队协作的时候可以明确分工，不同的任务有不同的划分，便于合作、阅读和维护。AFN，SDW等就用到了分类。声明私有方法等。

但是缺点是无法添加成员变量，但可以通过runtime的关联方法实现。分类的方法具有更高响应优先级，所以可能导致原始类以及父类的方法得不到调用，可以通过runtime遍历同名方法，取最后的方法。

**实现**：其实实现主要在runtime源码的`objc-runtime-new.mm`文件下，有一个叫做read_images的方法，将category和主类或元类注册到哈希表中，如果主类或元类已经实现了，就重建方法列表。分两种情况：Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中。另外，对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中。在`remethodizeClass`方法里，将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 `data()` 中 `method_lists（或 method_list）`、`properties` 和 `protocols` 的值。进一步，我们通过 `attachCategoryMethods` 函数的源码可以找到真正处理 Category 方法的 `attachMethodLists` 函数：`attachMethodLists`。

它的主要作用就是将类中的旧有方法和 Category 中新添加的方法整合成一个新的方法列表，并赋值给 `method_lists` 或 `method_list` 。通过探究这个处理过程，我们也印证了一个结论，那就是主类中的方法和 Category 中的方法在 runtime 看来并没有区别，它们是被同等对待的，都保存在主类的方法列表中。

不过，类的方法列表字段有一点特殊，它的结构是联合体，`method_lists` 和 `method_list` 共用同一块内存地址。当 `newCount` 的个数大于 1 时，使用 `method_lists` 来保存 `newLists` ，并将方法列表的**标志位**置为 `RW_METHOD_ARRAY` ，此时类的方法列表字段是 `method_list_t` 类型的指针数组；否则，使用 `method_list` 来保存 `newLists` ，并将方法列表的**标志位**置空，此时类的方法列表字段是 `method_list_t` 类型的指针。

## 数据库