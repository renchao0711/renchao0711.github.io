---
layout:     post
title:      "APP启动之前，它在想些什么？"
subtitle:   "深层次思考APP的启动"
date:       2017-05-07 14:35:00
author:     "renchao"
header-img: "img/2017.05.07.1.jpg"
tags: 
   - iOS
---
# APP启动之前，它在想些什么？

[TOC]

## 引言

### 理清编写程序的各种语言
可大致分为：低级语言 高级语言 专用语言 脚本语言    

**低级语言** 
   
机器语言、汇编语言（汇编语言源程序必须经过汇编，生成目标文件，然后执行 ）、符号语言  

**高级语言**
    
高级语言可分为编译型语言和解释型语言

编译型语言：
编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码(机器语言)，因此其目标程序可以脱离其语言环境独立执行，使用比较方便、效率较高 。但应用程序一旦需要修改，必须先修改源代码，再重新编译生成新的目标文件(.OBJ)才能执行，只有目标文件而没有源代码，修改很不方便。现在大多数的编程语言都是编译型的。编译程序将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行，同时又使他人难于盗用其中的技术。C、C++、objective-C、swift等都是编译实现的。

解释型语言：
解释型语言的实现中，翻译器并不产生目标机器代码，而是产生易于执行的中间代码，这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率较低。用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码后再执行。解释程序的优点是当语句出现语法错误时，可以立即引起程序员注意，而程序员在程序开发期间就能进行校正。对于解释型Basic语言，需要一个专门的解释器解释执行Basic程序，每条语言只有在执行才被翻译。这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，如Tcl、 Perl、Ruby、VBScript、JavaScript等。

混合型语言：
Java很特殊，Java程序也需要编译，但是没有直接编译称为机器语言，而是编译成为字节码，然后在Java虚拟机上用解释方式执行字节码。Python的也采用了类似Java的编译模式，先将Python程序编译成Python字节码，然后由一个专门的Python字节码解释器负责解释执行字节码。 


**专用语言**    
    
CAD系统中的绘图语言和DBMS的数据库查询语言。 

**脚本语言**    

为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。脚本语言一般都有相应的脚本引擎来解释执行。他们一般需要解释器才能运行。一个脚本通常是解释运行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。    

动态程序一般有两种实现方式，一是二进制方式，一是脚本方式。

二进制方式是先将我们编写的程序进行编译，变成机器可识别的指令代码（如.exe文件），然后再执行。这种编译好的程序我们只能执行、使用，却看不到他的程序内容。 

脚本程序相对一般程序开发来说比较接近自然语言，可以不经编译而是解释执行，利于快速开发或一些轻量的控制。一般的脚本语言的执行只同具体的解释执行器有关，所以只要系统上有相应语言的解释程序就可以做到跨平台。

脚本script是使用一种特定的描述性语言，依据一定的格式编写的可执行文件，又称作宏或批处理文件。脚本通常可以由应用程序临时调用并执行。各类脚本目前被广泛地应用于网页设计中，因为脚本不仅可以减小网页的规模和提高网页浏览速度，而且可以丰富网页的表现，如动画、声音等。 

脚本简单地说就是一条条的文字命令，这些文字命令是我们可以看到的（如可以用记事本打开查看、编辑），脚本程序在执行时，是由系统的一个解释器，将其一条条的翻译成机器可识别的指令，并按程序顺序执行。因为脚本在执行时多了一道翻译的过程，所以它比二进制程序执行效率要稍低一些。

我们上面提到的各种动态语言，如ASP、PHP、CGI、JSP等，都是脚本语言。 按目前的服务规则，虚拟主机网站只能采用脚本语言来实现 脚本英文为Script。实际上脚本就是程序，一般都是由应用程序提供的编程语言。应用程序包括浏览器(javascript、VBScript)、多媒体创作工具，应用程序的宏和创作系统的批处理语言也可以归入脚本之类。脚本同我们平时使用的VB、C语言等的区别主要是： 

1、脚本语法比较简单，比较容易掌握。

2、脚本与应用程序密切相关，所以包括相对应用程序自身的功能。

3、脚本一般不具备通用性，所能处理的问题范围有限。 

4、脚本语言(JavaScript,VBscript等)介于HTML和C,C++,Java,C#等编程语言之间。HTML通常用于格式化和链接文本。而编程语言通常用于向机器发出一系列复杂的指令。

5、脚本语言与编程语言也有很多相似地方，其函数与编程语言比较相象一些,其也涉及到变量。与编程语言之间最大的区别是编程语言的语法和规则更为严格和复杂一些。

6、与程序代码的关系:脚本也是一种语言，其同样由程序代码组成。注：脚本语言一般都有相应的脚本引擎来解释执行。他们一般需要解释器才能运行。JAVASCRIPT,ASP,PHP,PERL,Nuva都是脚本语言。C/C++编译、链接后，可形成独立执行的exe文件。 

7、脚本语言是一种解释性的语言,例如vbscript,javascript,installshield script等等,它不象c/c++等可以编译成二进制代码,以可执行文件的形式存在. 脚本语言不需要编译，可以直接用，由解释器来负责解释。 

8、脚本语言一般都是以文本形式存在,类似于一种命令. 举个例子说,如果你建立了一个程序,叫aaa.exe,可以打开.aa为扩展名的文件. 你为.aa文件的编写指定了一套规则(语法),当别人编写了.aa文件后,你的程序用这种规则来理解编写人的意图,并作出回应.那么,这一套规则就是脚本语言. 脚本是批处理文件的延伸，是一种纯文本保存的程序，一般来说的计算机脚本程序是确定的一系列控制计算机进行运算操作动作的组合，在其中可以实现一定的逻辑分支等。


## 编码阶段——点击Run之后

### 从人所能理解的语言到机器所能理解的语言
[美团点评技术团队的博文：高级语言的编译：链接及装载过程介绍](http://tech.meituan.com/linker.html)

> Command+B和Command+R：    
> 
> 前者就是bulid，只是编译，是为了检验代码中在编译期出现的错误，而不用在运行时确认的一种快速排错方式。  
> 后者就是编译加运行，直接运行程序。

### 编译

编译程序的工作过程如下图所示：

![](http://img.blog.csdn.net/20130930200246125)

编译主要依靠编译器来完成一系列的操作，主要的操作有预处理、词法分析、语法分析、语义分析、生成中间代码、生成目标代码以及目标代码优化。

![](http://jbcdn2.b0.upaiyun.com/2016/12/e06133010e789a3e1357ab29f707a130.jpg)

![](http://jbcdn2.b0.upaiyun.com/2016/12/b6e87cecf69cf0edff2555aa3c2f72a2.jpg)

OS X 现在使用的编译器是 LLVM （Low Level Virtual Machine），在最初使用的是 GCC作为官方的编译器。iOS编译采用Clang作为编译器前端，LLVM作为编译器后端。更多关于GCC、LLVM、Clang的关系及区别后面会详细说明。

##### 预编译
预编译主要用来处理那些源文件中以 #开头的预编译命令，比如#include等。

##### 词法分析
将输入分解为一个个独立的词法符号，也叫单词符号（token）

	// find a zero
	float  matchZero(char *s) {
	}
上面的小程序，返回下列单词流

	FLOAT、ID(MATCHZERO)、LPAREN、CHAR、ID(S) 、RPAREN   
	// 大概了解即可，觉得背这些词法符号定义对目前 iOS 开发用处不大
	
注释、宏、空格、换行等都不是单词

在词法分析阶段，源程序可以简单的看做是一个多行的字符串。词法分析阶段是编译过程的第一阶段，主要任务是对源程序从前到后（从左到右）逐个字符进行扫描，从中识别出一个个“单词”符号。词法分析程序输出的”单词“常采用二元组的方式，即单词类别和单词自身的值。词法分析过程依据的语言的此法规则，即描述“单词”结构的规则。
    
词法分析器一般来说有两种方法构造：手工构造和自动生成。手工构造可使用状态图进行工作，自动生成使用确定的有限自动机来实现。
    
词法分析器的功能输入源程序，按照构词规则分解成一系列单词符号。单词是语言中具有独立意义的最小单位，包括：
       (1)关键字 是由程序语言定义的具有固定意义的标识符。
       (2)标识符 用来表示各种名字，如变量名，数组名，过程名等等。
       (3)常数  常数的类型一般有整型、实型、布尔型、文字型等。
       (4)运算符 如+、-、*、/等等。
       (5)界符  如逗号、分号、括号、等等。

##### 语法分析

编译程序的语法分析器以单词符号作为输入，分析单词符号串是否形成符合语法规则的语法单位，如表达式、赋值、循环等，最后看是否构成一个符合各类语法的构成规则，按该语言使用的语法规则分析检查每条语句是否有正确的逻辑结构，程序是最终的一个语法单位。
    
语法分析的方法分为两种：自上而下分析法和自下而上分析法。自上而下就是从文法的开始符号出发，向下推导，推出句子。而自下而上分析法采用的是移进归约法，基本思想是：用一个寄存符号的先进后出栈，把输入符号一个一个地移进栈里，当栈顶形成某个产生式的一个候选式时，即把栈顶的这一部分归约成该产生式的左邻符号。
    
**语法分析只考虑构成该句子的语法单位是否符合语法规则**。例如在分析除法表达式时在语法分析阶段只分析运算符左右两边是否为变量、常量、表达式等，而不去管除数是否为0。

##### 语义分析
语义分析阶段主要是检查源程序是否存在语义错误，并收集类型信息供后面的代码生成阶段使用，只有语法和语义都正确的源程序才能翻译成正确的目标代码。语义分析的主要工作是进行各类型分析和检查。语义分析主要做的事情就是类型检查、以及符号表管理。

语法分析只能完成语法层面的分析，无法对整个语句的真正意义进行判别，比如，讲一个浮点数赋值指针类型的时候，语义分析器就会发现类型不匹配，编译器提出相应的错误警告。

比如语义分析的一个工作是进行类型审查，审查每个算符是否具有语言规范允许的运算对象，当不符合语言规范时，编译程序应报告错误。如有的编译程序要对实数用作数组下标的情况报告错误。再如分析除法表达式时在语义分析阶段就要分析该表达式的除数是否为零等。

##### 中间代码生成
编译器前端负责产生机器无关的中间代码，编译器后端负责对中间代码进行优化并转化为目标机器代码。

中间代码生成阶段的工作是根据语义分析的输出生成中间代码。中间代码是一种简单且含义明确的记号系统，可以有若干种形式，常见的有逆波兰记号、四元式、三元式和树。他们的共同特征是代码的方式与具体的机器无关。中间语言的复杂性介于源程序语言和机器语言之间。

中间代码实际上起一个编译器前段与后端分水岭的作用，目的是便于编译器的开发和移植和代码的优化。它既与机器指令的结构相近，又与具体的机器无关。并不是所有的编译程序都生成中间代码，一般快速编译程序直接生成目标代码，没有将中间代码翻译成目标代码的额外开销。

##### 代码优化
编译器后端主要包括代码生成器、代码优化器。代码生成器将中间代码转换为目标代码，代码优化器主要是进行一些优化，比如删除多余指令，选择合适寻址方式等

代码优化是指对程序进行多种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。所谓等价，是指不改变程序的运行结果。所谓有效，主要指目标代码运行时间较短，以及占用的存储空间较小。这种变换称为优化。
    
两类优化：一类是对语法分析后的中间代码进行优化，它不依赖于具体的计算机；另一类是在生成目标代码时进行的，它在很大程度上依赖于具体的计算机。对于前一类优化，根据它所涉及的程序范围可分为局部优化、循环优化和全局优化三个不同的级别。

#####目标代码生成
目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。目标代码生成阶段的工作与目标机器的体系结构密切相关。目标代码有三种形式：
  
① 可以立即执行的机器语言代码，所有地址都重定位；
         
② 待装配的机器语言模块，当需要执行时，由连接装入程序把它们和某些运行程序连接起来，转换成能执行的机器语言代码；
         
③ 汇编语言代码，须经过汇编程序汇编后，成为可执行的机器语言代码。
    
目标代码生成阶段应考虑直接影响到目标代码速度的三个问题：一是如何生成较短的目标代码；二是如何充分利用计算机中的寄存器，减少目标代码访问存储单元的次数；三是如何充分利用计算机指令系统的特点，以提高目标代码的质量。

#####出错处理
用户编写的源程序不可避免的会有一些错误，这些错误大致可以分为静态错误和动态错误。动态错误也称动态语义错误，它们发生在程序运行时，例如除数为0、引用数组元素下标错误等。静态错误是之编译阶段发现的程序错误，可分为语法错误和静态语义错误，如单词拼写错误、标点符号错误、表达式缺少操作数、括号不匹配等有关语言结构上的错误称为语法错误，而语义分析时发现的运算符与运算对象不合法等错误属于静态语义错误。语义分析阶段主要检查源程序是否包含静态语义错误，而一般的编译器很难检查出动态语义错误。

### 汇编
目标代码需要经过汇编器处理，才能变成机器上可以执行的指令。生成对应的.o文件


### 链接
链接器（这里指的是静态链接器）将多个目标文件合并为一个可执行文件，在OS X和iOS中的可执行文件是Mach-O。

> ####Mach-O
> Mach-O是针对不同运行时可执行文件的类型。
文件类型：
>
- Exectuable: 应用的主要二进制
- Dylib: 动态链接库
- Bundle: 不能被链接的Dylib，只能在运行时使用dlopen()加载

>Mach-O镜像文件

>所有Mach-O(可使用MachOView工具查看)都包含：__TEXT, __DATA, __LINKEDIT:
>
- __TEXT 包含Mach header, 被执行的代码和只读常量。
- __DATA 包含全局变量，静态变量。可读写。
- __LINKEDIT 包含加载程序的元数据，比如函数的名称和地址。
链接呢，又分为静态链接和动态链接

静态链接

静态链接：在编译链接期间发挥作用，把目标文件和静态库一起链接形成可执行文件
![](http://jbcdn2.b0.upaiyun.com/2016/12/1044a796aa1a8a108ac9eefbf5e19bf7.jpg)

动态链接

动态链接：链接过程推迟到运行时再进行。对于动态链接和静态链接，各有千秋

> 如果多个程序都用到了一个库，那么每个程序都要将其链接到可执行文件中，非常冗余，动态链接的话，多个程序可以共享同一段代码，不需要在磁盘上存多份拷贝，但是动态链接发生在启动或运行时，增加了启动时间，造成一些性能的影响。

> 静态库不方便升级，必须重新编译，动态库的升级更加方便

### 代码签名
我们每次build之后，都会发现工程目录下多了一个.app文件
![](http://jbcdn2.b0.upaiyun.com/2016/12/759eb5bd2be3a9c2f08803e466c88811.jpg)
在 .app目录中，有又一个叫_CodeSignature的子目录，这是一个 plist文件，里面包含了程序的代码签名，你的程序一旦签名，就没有办法更改其中的任何东西，包括资源文件，可执行文件等，iOS系统会检查这个签名。

签名过程本身是由命令行工具 codesign 来完成的。如果你在 Xcode中build一个应用，这个应用构建完成之后会自动调用codesign 命令进行签名，这也是Link之后的一个关键步骤。

### 启动
在经过一系列处理后，终于形成一个可以在系统上跑起来的可执行程序，剩下的就是启动运行.

## 使用阶段——APP启动流程
> iOS触摸事件的流动见：[iOS触摸事件的流动](http://shellhue.github.io/2017/03/04/FlowOfUITouch/)

下图是App启动流程的关键节点展示：

![](http://cc.cocimg.com/api/uploads/20160115/1452850055901358.png)

关于该图的解读，请参考这篇文章：[由App的启动说起](http://www.cocoachina.com/ios/20160118/15019.html "由App的启动说起")

### main函数之前——从dyld开始
#####动态链接库

iOS 中用到的所有系统 framework 都是动态链接的，类比成插头和插排，静态链接的代码在编译后的静态链接过程就将插头和插排一个个插好，运行时直接执行二进制文件；而动态链接需要在程序启动时去完成“插插销”的过程，所以在我们写的代码执行前，动态连接器需要完成准备工作。

除了多了的CoreGraphics（被 UIKit 依赖）外，有两个默认添加的 lib：libobjc 即 objc 和 runtime，libSystem 中包含了很多系统级别 lib，列几个熟知的：

- libdispatch ( GCD )
- libsystem_c ( C语言库 )
- libsystem_blocks ( Block )
- libcommonCrypto ( 加密库，比如常用的 md5 函数 )

这些 lib 都是dylib格式（如 windows 中的 dll ），系统使用动态链接有几点好处：

- 代码共用：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份
- 易于维护：由于被依赖的 lib 是程序执行时才 link 的，所以这些 lib 很容易做更新，比如libSystem.dylib 是 libSystem.B.dylib 的替身，哪天想升级直接换成 libSystem.C.dylib 然后再替换替身就行了
- 减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多

#####dyld
dyld（the dynamic link editor），Apple 的动态链接器，系统 kernel 做好启动程序的初始准备后，交给 dyld 负责，援引并翻译《 Mike Ash 这篇 blog 》对 dyld 作用顺序的概括：

- 从 kernel 留下的原始调用栈引导和启动自己
- 将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制
- non-lazy 符号立即 link 到可执行文件，lazy 的存表里
- Runs static initializers for the executable
- 找到可执行文件的 main 函数，准备参数并调用
- 程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口
- 程序main函数 return 后执行 static terminator
- 某些场景下 main 函数结束后调 libSystem 的 _exit 函数

#####ImageLoader
当然这个 image 不是图片的意思，它大概表示一个二进制文件（可执行文件或 so 文件），里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。

两步走：

- 在程序运行时它先将动态链接的 image 递归加载 （也就是上面测试栈中一串的递归调用的时刻）
- 再从可执行文件 image 递归加载所有符号

当然所有这些都发生在我们真正的main函数执行前。

#####runtime 与 +load

刚才讲到 libSystem 是若干个系统 lib 的集合，所以它只是一个容器 lib 而已，而且它也是开源的，里面实质上就一个文件，init.c，由 libSystem_initializer 逐步调用到了 _objc_init，这里就是 objc 和 runtime 的初始化入口。

除了 runtime 环境的初始化外，_objc_init中绑定了新 image 被加载后的 callback：

	dyld_register_image_state_change_handler(
	dyld_image_state_bound, 1, &map_images);
	dyld_register_image_state_change_handler(
	dyld_image_state_dependents_initialized, 0, &load_images);
可见 dyld 担当了 runtime 和 ImageLoader 中间的协调者，当新 image 加载进来后交由 runtime 大厨去解析这个二进制文件的符号表和代码。用断点法，断住神秘的 +load 函数：

![](http://ww1.sinaimg.cn/mw690/51530583jw1ejyjgvetq1j20jk0bc0uf.jpg)

清楚的看到整个调用栈和顺序：

- dyld 开始将程序二进制文件初始化
- 交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号
- 由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理
- runtime 接手后调用 map_images 做解析和处理，接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法

至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法（动态添加 Class、swizzle 等等才能生效）

#####总结
整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存，
动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。
值得说明的是，这个过程远比写出来的要复杂，这里只提到了 runtime 这个分支，还有像 GCD、XPC 等重头的系统库初始化分支没有提及（当然，有缓存机制在，它们也不会玩命初始化），总结起来就是 main 函数执行之前，系统做了茫茫多的加载和初始化工作，但都被很好的隐藏了，我们无需关心。
### main函数
	
	#import <UIKit/UIKit.h> 
	#import "AppDelegate.h" 
 
	int main(int argc, char * argv[]) 
	{
		@autoreleasepool { 
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); 
    	} 
	} 

函数原型为

`UIKIT_EXTERN int UIApplicationMain(int argc, char *argv[], NSString *principalClassName, NSString *delegateClassName); `

首先说说UIKIT_EXTERN，

	#ifdef __cplusplus

	#define UIKIT_EXTERN extern "C" __attribute__((visibility ("default")))

	#else

	#define UIKIT_EXTERN         extern __attribute__((visibility ("default")))

	#endif

宏定义 `#ifdef __cplusplus`，如果宏定义了`__cplusplus`，则`#define UIKIT_EXTERN extern "C" __attribute__((visibility ("default")))`，否则`#define UIKIT_EXTERN         extern __attribute__((visibility ("default")))`

区分在是否定义了\__cplusplus，\__cplusplus很直观的翻译cpp，也就是C++。\__cplusplus标示符用来判断程序是用c还是c++编译程序编译的。当编译c++程序时,这个标示符会被定义,编译c程序时,不会定义。接着对全句理解，如果已经宏定义了\__cplusplus（也就是说当前源代码被当作C＋＋源代码处理。否则当前源代码被当中C源代码处理），那么`extern "C" __attribute__((visibility ("default")))`。

extern "C"很好理解，在C＋＋发明之初，为了兼容在当时正处主流的C语言，按照C编译方式进行编译的作用。可以理解为extern "C"就是告诉编译器（也就是Xcode）在编译的时候，要按照原来C语言的编译方式对（全局）函数和变量进行编译。

C++是一种“不完全的面相对象语言”，对比C/C++ 两种编译方式，C++支持重载，从而使得函数的编译方式不得不同于C的编译，举个栗子，有个函数，更新学生信息的`void upDataStudentInfo(int, int)`;C方式去编译此函数，不会对函数名进行特殊处理，编译后的函数名为`_upDataStudentInfo`,反观C++方式的编译，为了支持重载，`upDataStudentInfo`函数会变成类似`_upDataStudentInfo_int_int`的函数名，同样`void upDataStudentInfo(float, int)`会编译成`_upDataStudentInfo_float_int`类似的函数名。这些都可在.obj文件中查看。此处对于C/C++混编互调的深层学习以及使用，不做分析，我只是个搞iOS的，在编译后寻找函数名等多少也能说出些来，但实在不算熟悉，就不误人子弟了。

接下来就是`__attribute__((visibility ("default")))`，同出于C系语言，`__attribute__`是用来设置属性的，包括函数、变量、类型，这里我们使用的是设置函数的属性，\__attribute__听传闻说是自测利器，同样在C中，或者C++中，作为入门级的iOSer，理解就可。`visibility`属性是设置将本项目的函数作为库使用时的可见性。

设置了`__attribute__((visibility ("default")))`，函数的public属性对外可见。

so，总结成一句话，`UIKIT_EXTERN`就是将函数修饰为兼容以往C编译方式的、具有extern属性(文件外可见性)、public修饰的方法或变量库外仍可见的属性。

继续分析`int UIApplicationMain(int argc, char *argv[], NSString * __nullable principalClassName, NSString * __nullable delegateClassName);`

前面两个参数出于main，从第三个开始NSString * __nullable principalClassName，一个字符串类型的参数principalClassName，直译为主要类，必须为UIApplication或者其子类，代表着当前app自身。并且如果此参数为nil的话，则默认为@"UIApplication"。

第四个参数delegateClassName，代理类。在UIApplication中有个delegate的变量，delegate遵守UIApplicationDelegate协议负责程序的生命周期。UIApplication 接收到所有的系统事件和生命周期事件时，都会把事件传递给UIApplicationDelegate进行处理，至于为什么没让UIApplication自己去实现，涉及到了上帝类、框架类，过深，不讲。

综合来说UIApplicationMain主要负责三件事

1、从给定的类名初始化应用程序对象，也就是初始化UIApplication或者子类对象的一个实例，如果你在这里给定的是nil，那么 系统会默认UIApplication类，也就主要是这个类来控制以及协调应用程序的运行。在后续的工作中，你可以用静态方法sharedApplication 来获取应用程序的句柄。 

2、从给定的应用程序委托类，初始化一个应用程序委托。并把该委托设置为应用程序的委托，这里就有如果传入参数为nil，会调用函数访问 Info.plist文件来寻找主nib文件，获取应用程序委托。 

3、启动主事件循环，并开始接收事件。 

> main()调用之后的加载时间
> 
> - 准备阶段，主要是图片的解码
> - 布局阶段，-(void)layoutSubViews()
> - 绘制阶段，-(void)drawRect:(CGRect)rect 
> - 启动阶段必要服务的启动、必要数据的创建和读取。
> 
> 优化启动时间
> 
> - 内嵌的dylib尽可能少，或者合并起来。
> - Rebase/Binding减少__DATA中需要修正的指针。 对于oc来说减少 class, selector,
category 这些元数据的数量，对与c++来说，减少虚函数数量。swift结构体需要修正的比较少。
> - 将不必须在+load中做的事延迟到+ initialize中。
> - 不使用xib，直接用代码加载首页视图。
> - release版不要用NSLog输出。
> - 启动时的网络请求尽可能异步。

更多关于iOS卡顿优化请参考本人另一篇博文[iOS卡顿及优化](https://renchao0711.github.io/2017/05/07/iOS%E7%95%8C%E9%9D%A2%E5%8D%A1%E9%A1%BF%E5%8F%8A%E4%BC%98%E5%8C%96/)、[iOS 事件处理机制与图像渲染过程]([http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=400417748&idx=1&sn=0c5f6747dd192c5a0eea32bb4650c160&3rd=MzA3MDU4NTYzMw==&scene=6#rd](http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=400417748&idx=1&sn=0c5f6747dd192c5a0eea32bb4650c160&3rd=MzA3MDU4NTYzMw==&scene=6#rd))。

### main函数之后
![](http://cc.cocimg.com/api/uploads/20161111/1478845880704414.jpg)

1. main函数
2. UIApplicationMain
	- 创建UIApplication对象
	- 创建UIApplication的delegate对象
	- delegate对象开始处理(监听)系统事件(没有storyboard)
	- 程序启动完毕的时候, 就会调用代理的application:didFinishLaunchingWithOptions:方法
	- 在application:didFinishLaunchingWithOptions:中创建UIWindow
	- 创建和设置UIWindow的rootViewController
	- 显示窗口
3. 根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(有storyboard)
	- 创建UIWindow
	- 创建和设置UIWindow的rootController
	- 显示窗口

AppDelegate的代理方法：

	//app启动完毕后就会调用
	- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{
	}
 
	//app程序失去焦点就会调用                    
	- (void)applicationWillResignActive:(UIApplication *)application{
	}
 
	//app进入后台的时候调用， 一般在这里保存应用的数据(游戏数据,比如暂停游戏)
	- (void)applicationDidEnterBackground:(UIApplication *)application{
	}
 
	//app程序程序从后台回到前台就会调用
	- (void)applicationWillEnterForeground:(UIApplication *)application{
	}
 
	//app程序获取焦点就会调用
	- (void)applicationDidBecomeActive:(UIApplication *)application{
 	}
 
	// 内存警告，可能要终止程序，清除不需要再使用的内存
	- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application{
	}
 
	// 程序即将退出调用
	- (void)applicationWillTerminate:(UIApplication *)application{
	}

**AppDelegate加载顺序**

1. application:didFinishLaunchingWithOptions:	
2. applicationDidBecomeActive:

**ViewController中的加载顺序**

1. loadView
2. viewDidLoad
3. viewWillAppear
4. viewWillLayoutSubviews
5. viewDidLayoutSubviews
6. viewDidAppear

**View中的加载顺序**

1. initWithCoder（如果没有storyboard就会调用initWithFrame，这里两种方法视为一种）
2. awakeFromNib
3. layoutSubviews
4. drawRect

**一些方法的使用时机**

    + (void)load;
应用程序启动就会调用的方法，在这个方法里写的代码最先调用。

    + (void)initialize;
用到本类时才调用，这个方法里一般设置导航控制器的主题等，如果在后面的方法设置导航栏主题就太迟了！

    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions;
这个方法里面会创建UIWindow，设置根控制器并展现，比如某些应用程序要加载授权页面也是在这加，也可以设置观察者，监听到通知切换根控制器等。

    - (void)awakeFromNib;
在使用IB的时候才会涉及到此方法的使用，当.nib文件被加载的时候，会发送一个awakeFromNib的消息到.nib文件中的每个对象，每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。在这个方法里设置view的背景等一系列普通操作。

    - (void)loadView;
创建视图的层次结构，在没有创建控制器的view的情况下不能直接写 self.view 因为self.view的底层是：

    if（_view == nil）{
    _view = [self loadView]
    }
这么写会直接造成死循环。

如果重写这个loadView方法里面什么都不写，会显示黑屏。

    - (void)viewWillLayoutSubviews;
视图将要布局子视图，苹果建议的设置界面布局属性的方法，这个方法和viewWillAppear里，系统的底层都是没有写任何代码的，也就是说这里面不写super 也是可以的。

    - (void)layoutSubviews;
在这个方法里一般设置子控件的frame。

    - (void)drawRect:(CGRect)rect;
UI控件都是画上去的，在这一步就是把所有的东西画上去。drawRect方法只能在加载时调用一次，如果后面还需要调用，比如下载进度的圆弧，需要一直刷帧，就要使用setNeedsDisplay来定时多次调用本方法。

    - (void)applicationDidBecomeActive:(UIApplication *)application;
这是AppDelegate的应用程序获取焦点方法，真正到了这里，才是所有东西全部加载完毕。

**启动分析**

应用启动时，会播放一个启动动画。iPhone上是400ms，iPad上是500ms。如果应用启动过慢，用户就会放弃使用，甚至永远都不再回来。为了防止一个应用占用过多的系统资源，开发iOS的苹果工程师门设计了一个“看门狗”的机制。在不同的场景下，“看门狗”会监测应用的性能。如果超出了该场景所规定的运行间，“看门狗”就会强制终结这个应用的进程。

iOS App启动时会链接并加载Framework和static lib，执行UIKit初始化，然后进入应用程序回调，执行Core Animation transaction等。每个Framework都会增加启动时间和占用的内存，不要链接不必要的Framework，必要的Framework不要标记为Optional。避免创建全局的C++对象。

初始化UIKit时字体、状态栏、user defaults、Main.storyboard会被初始化。User defaults本质上是一个plist文件，保存的数据是同时被反序列化的，不要在user defaults里面保存图片等大数据。

对于 OC 来说应尽量减少 Class,selector 和 category 这些元数据的数量。编码原则和设计模式之类的理论会鼓励大家多写精致短小的类和方法，并将每部分方法独立出一个类别，但这会增加启动时间。在调用的地方使用初始化器，不要使用\\atribute((constructor)) 将方法显式标记为初始化器，而是让初始化方法调用时才执行。比如使用 dispatch_once(),pthread_once() 或 std::once()。也就是在第一次使用时才初始化，推迟了一部分工作耗时。

建立网络连接前需要做域名解析，如果网关出现问题，dns解析不正常时，dns的超时时间是应用控制不了的。在程序设计时要考虑这些问题，如果程序启动时有网络连接，应尽快的结束启动过程，网络访问通过线程解决，而不阻塞主线程的运行。

## 苹果编译器的前世今生
OS X 现在使用的编译器是 [LLVM](http://www.nagain.com/activity/article/4/) （Low Level Virtual Machine），在最初使用的是 GCC作为官方的编译器，但是由于下面的众多限制，apple 使用了自己的一套编译器。

[GCC，LLVM，Clang编译器对比](http://www.cnblogs.com/qoakzmxncb/archive/2013/04/18/3029105.html)

知乎链接——[Clang 比 GCC 好在哪里？](https://www.zhihu.com/question/20235742)

GCC 原名为GNU C语言编译器，它原本只能处理 C语言，后来扩展了Objective-C、Java等语言，但是对于Objective-C的处理还是存在众多不便
GCC 效率低下、性能不强
苹果开发自己的编译器，有利于开展自己的工具链，比如后期做 Swift、lldb 等
借用 sunnyxx的图片 来展现下 llvm 的基本架构

![](http://jbcdn2.b0.upaiyun.com/2016/12/a54efe211a8c320399d51519bee5f8d8.jpg)

编译器分别编译器前端（[clang](http://blog.csdn.net/snsn1984/article/details/17716261)）和编译器后端，编译器前端负责产生机器无关的中间代码，编译器后端负责对中间代码进行优化并转化为目标机器代码，对于为什么需要 中间代码这个东西，看个图就一目了然啦（IR：intermediate representation中间表示）

![](http://jbcdn2.b0.upaiyun.com/2016/12/85312a7f20b79742c070115e10bc8054.jpg)

Clang的任务：预处理、词法分析、语法分析、语义分析、静态分析、生成中间代码。

- 预处理：以#开头的代码预处理。包括引入的头文件和自定义宏。
- 词法分析：每一个.m源文件的声明和定义从string转化为特殊的标记流。
- 语法分析：将标记流解析成一颗抽象语法树（ abstract syntax tree-AST）。
- 静态分析：包含类型检查和其他检查。
- 中间代码生成：生成LLVM代码。

LLVM的任务：将代码进行优化并产生汇编代码。

- 汇编器：将可读的汇编代码转换为机器代码，最终创建一个目标对象.o文件。
- 链接器的任务：把目标文件和库相连，最终输出可运行文件：a.out。


## iOS的触摸事件
## 番外之调试器的工作原理
下次再更
## 感谢作者
[http://blog.sunnyxx.com/2014/08/30/objc-pre-main/](http://blog.sunnyxx.com/2014/08/30/objc-pre-main/)
[http://blog.csdn.net/zhanggaofeixy/article/details/52180048](http://blog.csdn.net/zhanggaofeixy/article/details/52180048)	
[http://www.cocoachina.com/industry/20140709/9075.html](http://www.cocoachina.com/industry/20140709/9075.html "http://www.cocoachina.com/industry/20140709/9075.html")		
[http://www.cocoachina.com/ios/20161114/18054.html](http://www.cocoachina.com/ios/20161114/18054.html)

