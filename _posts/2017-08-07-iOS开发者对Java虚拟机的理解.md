---
layout:     post
title:      "iOSer对Java虚拟机的理解"
subtitle:   "什么是JVM"
date:       2017-08-07 08:25:00
author:     "renchao"
header-img: "img/2017.05.07.jpg"
tags: 
   - iOS
---



# Java虚拟机

### 概述

对于JVM自身的物理结构，我们可以从下图了解：

![img](http://wiki.jikexueyuan.com/project/java-vm/images/jvm.gif)

维基百科对JVM的解释为：

> Java虚拟机有自己完善的[硬体](https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BD%93)架构，如[处理器](https://zh.wikipedia.org/wiki/%E5%A4%84%E7%90%86%E5%99%A8)、[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)、[寄存器](https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8)等，还具有相应的[指令](https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4)系统。JVM屏蔽了与具体[操作系统](https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)平台相关的信息，使得Java[程序](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F)只需生成在Java虚拟机上运行的目标代码（[字节码](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81)），就可以在多种平台上不加修改地运行。通过对中央处理器（[CPU](https://zh.wikipedia.org/wiki/CPU)）所执行的软件实现，实现能执行[编译](https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91)过的Java程序码（[Applet](https://zh.wikipedia.org/wiki/Applet)与应用程序）。

也就是说，JVM是Java的核心和基础，在Java编译器和OS平台之间的虚拟处理器。它是一种基于下层的操作系统和硬件平台并利用软件方法来实现的抽象的计算机，可以在上面执行 Java 的字节码程序。

Java 编译器只需面向 JVM，生成 JVM 能理解的代码或字节码文件。Java 源文件经编译器，编译成字节码程序，通过 JVM 将每一条指令翻译成不同平台机器码，通过特定平台运行。

简单的说，JVM 就相当于一台柴油机,它只能用 Java (柴油)运行,JVM 就是 Java 的虚拟机,有了 JVM 才能运行 Java 程序。

详细说，在执行一个所谓的java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程，而不是我们写的一个个的.class文件。这个叫做虚拟机的进程处理一些底层的操作，比如内存的分配和释放等等。我们编写的class文件只是虚拟机进程执行时需要的“原料”。这些“原料”在运行时被加载到虚拟机中，被虚拟机解释执行，以控制虚拟机实现我们java代码中所定义的一些相对高层的操作，比如创建一个文件等，可以将class文件中的信息看做对虚拟机的控制信息，也就是一种虚拟指令。

### Java代码编译和执行的整个过程

整个过程有三个重要部分：

- Java源码编译机制
- 类加载机制
- 类执行机制

#### Java源码编译机制

Java源代码编译成JVM字节码的流程为：

![img](http://wiki.jikexueyuan.com/project/java-vm/images/javadebug.gif)

经过这些处理后，生成的.class文件由以下部分组成：

- **结构信息**   包括 class 文件格式版本号及各部分的数量与大小的信息。
- **元数据**   对应于 Java 源码中<u>声明</u>与<u>常量</u>的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池。
- **方法信息**   对应 Java 源码中<u>语句和表达式</u>对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息。

#### JVM执行字节码

JVM中对Java字节码的执行过程为：

![img](http://wiki.jikexueyuan.com/project/java-vm/images/jvmdebug.gif)

#### 类加载机制

JVM 的类加载是通过 ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：![img](http://wiki.jikexueyuan.com/project/java-vm/images/jvmclass.gif)

#### 类执行机制

JVM 是基于栈的体系结构来执行 class 字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用。而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。栈的结构如下图所示：

![img](http://wiki.jikexueyuan.com/project/java-vm/images/classrun.gif)

### Java内存区域与内存溢出

#### 内存区域

![img](http://wiki.jikexueyuan.com/project/java-vm/images/jvmdata.png)

**程序计数器：**一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，当线程在执行一个 Java 方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址。字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。

**Java 虚拟机栈：**该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的 Code 属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

**本地方法堆：**该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。

**Java堆：**Java Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。

**方法区：**方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”，但这仅仅对于 Sun HotSpot 来讲。运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

